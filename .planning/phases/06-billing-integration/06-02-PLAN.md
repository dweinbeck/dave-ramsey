---
phase: 06-billing-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/[envelopeId]/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/[transactionId]/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/reorder/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/analytics/route.ts
autonomous: true

must_haves:
  truths:
    - "All 8 mutation endpoints (POST/PUT/DELETE) return 402 JSON error when billing access is readonly"
    - "GET /api/envelopes returns billing status in response alongside envelope data"
    - "GET /api/envelopes/transactions returns billing status in response alongside transaction data"
    - "GET /api/envelopes/analytics returns billing status in response alongside analytics data"
    - "checkEnvelopeAccess() is called after verifyUser() in every envelope route handler"
  artifacts:
    - path: "src/app/api/envelopes/route.ts"
      provides: "Billing-gated GET + POST for envelopes"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/[envelopeId]/route.ts"
      provides: "Billing-gated PUT + DELETE for single envelope"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/transactions/route.ts"
      provides: "Billing-gated GET + POST for transactions"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/transactions/[transactionId]/route.ts"
      provides: "Billing-gated PUT + DELETE for single transaction"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/allocations/route.ts"
      provides: "Billing-gated POST for allocations"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/reorder/route.ts"
      provides: "Billing-gated PUT for reorder"
      contains: "checkEnvelopeAccess"
    - path: "src/app/api/envelopes/analytics/route.ts"
      provides: "Billing-aware GET for analytics"
      contains: "checkEnvelopeAccess"
  key_links:
    - from: "all route files"
      to: "src/lib/envelopes/billing.ts"
      via: "import checkEnvelopeAccess"
      pattern: "checkEnvelopeAccess"
    - from: "GET handlers"
      to: "API response"
      via: "billing status in JSON response body"
      pattern: "billing.*mode"
---

<objective>
Add billing access checks to all envelope API routes: mutation endpoints (POST/PUT/DELETE) reject with 402 when read-only, and GET endpoints include billing status in their response for client-side rendering.

Purpose: Server-side enforcement is mandatory -- client-side UI disabling is only a courtesy. This plan ensures no mutation can bypass billing.
Output: All 7 envelope route files updated with billing gates.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-billing-integration/06-RESEARCH.md
@.planning/phases/06-billing-integration/06-01-SUMMARY.md

# Source files (must read all 7 route files before modifying):
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/[envelopeId]/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/[transactionId]/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/reorder/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/analytics/route.ts
@/Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/billing.ts
@/Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate mutation endpoints with billing checks</name>
  <files>
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/[envelopeId]/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/[transactionId]/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/reorder/route.ts
  </files>
  <action>
For each of the 6 route files containing mutation endpoints, add billing enforcement:

**Import to add** (at top of each file):
```typescript
import { checkEnvelopeAccess } from "@/lib/envelopes/billing";
```

**Pattern for each POST/PUT/DELETE handler** -- add immediately after auth verification, before any business logic:
```typescript
const access = await checkEnvelopeAccess(auth.uid, auth.email);
if (access.mode === "readonly") {
  return Response.json(
    { error: "Insufficient credits. Purchase credits to continue editing." },
    { status: 402 },
  );
}
```

**Complete list of handlers to gate (8 total):**

1. `POST` in `src/app/api/envelopes/route.ts` -- after `if (!auth.authorized)` check
2. `PUT` in `src/app/api/envelopes/[envelopeId]/route.ts` -- after `if (!auth.authorized)` check
3. `DELETE` in `src/app/api/envelopes/[envelopeId]/route.ts` -- after `if (!auth.authorized)` check
4. `POST` in `src/app/api/envelopes/transactions/route.ts` -- after `if (!auth.authorized)` check
5. `PUT` in `src/app/api/envelopes/transactions/[transactionId]/route.ts` -- after `if (!auth.authorized)` check
6. `DELETE` in `src/app/api/envelopes/transactions/[transactionId]/route.ts` -- after `if (!auth.authorized)` check
7. `POST` in `src/app/api/envelopes/allocations/route.ts` -- after `if (!auth.authorized)` check
8. `PUT` in `src/app/api/envelopes/reorder/route.ts` -- after `if (!auth.authorized)` check

**IMPORTANT:** Place the billing check INSIDE the try block but BEFORE any body parsing or business logic. The billing check can throw non-402 errors (Firestore issues), so it should be inside the try/catch. The order is: auth check -> try { billing check -> body parse -> business logic } catch { error handling }.

For [envelopeId] and [transactionId] routes that have `const { envelopeId } = await params;` or similar: the billing check should go BEFORE the params destructure (no need to parse params if billing blocks the request).

Actually, for consistency and simplicity: place the billing check as the FIRST thing inside the try block, before `const { envelopeId } = await params` or `const body = await request.json()`.
  </action>
  <verify>
Run `cd /Users/dweinbeck/Documents/personal-brand && npx tsc --noEmit` to verify all routes compile.
Use grep to verify all 6 route files import checkEnvelopeAccess:
`grep -r "checkEnvelopeAccess" src/app/api/envelopes/ --include="*.ts" -l`
Should return 7 files (6 mutation + analytics will be done in task 2).
  </verify>
  <done>
All 8 mutation endpoints reject with 402 when billing access is readonly. Each handler calls checkEnvelopeAccess(auth.uid, auth.email) after auth verification and before any business logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add billing status to GET endpoint responses</name>
  <files>
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/transactions/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/analytics/route.ts
  </files>
  <action>
Modify the 3 GET handlers to include billing status in their JSON response. The billing check runs on GET too (this triggers the charge on first access per the requirement), but a readonly result does NOT block the response -- it just includes the status for the UI.

**Pattern for each GET handler:**

Add `import { checkEnvelopeAccess } from "@/lib/envelopes/billing"` if not already imported (it will already be imported for route.ts files that also have POST).

For files that ONLY have GET (analytics/route.ts), add the import.

**GET /api/envelopes** (already has POST, so import exists):
```typescript
export async function GET(request: Request) {
  const auth = await verifyUser(request);
  if (!auth.authorized) return unauthorizedResponse(auth);

  try {
    const [access, data] = await Promise.all([
      checkEnvelopeAccess(auth.uid, auth.email),
      listEnvelopesWithRemaining(auth.uid),
    ]);

    return Response.json({
      ...data,
      billing: {
        mode: access.mode,
        reason: "reason" in access ? access.reason : undefined,
      },
    });
  } catch (error) {
    console.error(
      "GET /api/envelopes error:",
      error instanceof Error ? error.message : "Unknown",
    );
    return Response.json(
      { error: "Failed to load envelopes." },
      { status: 500 },
    );
  }
}
```

**GET /api/envelopes/transactions** (already has POST, so import exists):
```typescript
export async function GET(request: Request) {
  const auth = await verifyUser(request);
  if (!auth.authorized) return unauthorizedResponse(auth);

  try {
    const { searchParams } = new URL(request.url);
    const weekStart = searchParams.get("weekStart");
    const weekEnd = searchParams.get("weekEnd");

    if (!weekStart || !weekEnd) {
      return Response.json(
        { error: "weekStart and weekEnd query params are required." },
        { status: 400 },
      );
    }

    const [access, data] = await Promise.all([
      checkEnvelopeAccess(auth.uid, auth.email),
      listTransactionsForWeek(auth.uid, weekStart, weekEnd),
    ]);

    return Response.json({
      ...data,
      billing: {
        mode: access.mode,
        reason: "reason" in access ? access.reason : undefined,
      },
    });
  } catch (error) {
    console.error(
      "GET /api/envelopes/transactions error:",
      error instanceof Error ? error.message : "Unknown",
    );
    return Response.json(
      { error: "Failed to load transactions." },
      { status: 500 },
    );
  }
}
```

**GET /api/envelopes/analytics** (needs new import):
```typescript
import { checkEnvelopeAccess } from "@/lib/envelopes/billing";
// ... existing imports ...

export async function GET(request: Request) {
  const auth = await verifyUser(request);
  if (!auth.authorized) return unauthorizedResponse(auth);

  try {
    const [access, data] = await Promise.all([
      checkEnvelopeAccess(auth.uid, auth.email),
      getAnalyticsData(auth.uid),
    ]);

    return Response.json({
      ...data,
      billing: {
        mode: access.mode,
        reason: "reason" in access ? access.reason : undefined,
      },
    });
  } catch (error) {
    console.error(
      "GET /api/envelopes/analytics error:",
      error instanceof Error ? error.message : "Unknown",
    );
    return Response.json(
      { error: "Failed to load analytics." },
      { status: 500 },
    );
  }
}
```

**Key design note:** Use `Promise.all([checkEnvelopeAccess(), dataFetch()])` to run billing check and data fetch in parallel. This avoids adding latency -- billing and data loading happen concurrently. The billing status from `access` maps to the BillingStatus type: `{ mode, reason }`. The `"reason" in access ? access.reason : undefined` pattern correctly handles the discriminated union (readwrite may or may not have reason, readonly always has reason: "unpaid").
  </action>
  <verify>
Run `cd /Users/dweinbeck/Documents/personal-brand && npx tsc --noEmit` to verify all routes compile.
Use grep to verify all 7 route files now reference checkEnvelopeAccess:
`grep -r "checkEnvelopeAccess" src/app/api/envelopes/ --include="*.ts" -l`
Should return all 7 route files.
  </verify>
  <done>
All 3 GET endpoints return billing: { mode, reason } in their JSON response alongside existing data. Billing check runs in parallel with data fetch. Analytics route has new billing import.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/dweinbeck/Documents/personal-brand && npx tsc --noEmit` passes
2. `grep -r "checkEnvelopeAccess" src/app/api/envelopes/ --include="*.ts" -l` returns all 7 route files
3. `grep -c "status: 402" src/app/api/envelopes/**/route.ts` shows 402 in all mutation routes
4. `grep -r "billing:" src/app/api/envelopes/ --include="*.ts"` shows billing field in GET responses
</verification>

<success_criteria>
- All 8 mutation endpoints (POST/PUT/DELETE across 6 files) return 402 when billing access is readonly
- All 3 GET endpoints include billing: { mode, reason } in their JSON response
- checkEnvelopeAccess imported and called in all 7 route files
- Billing check runs after auth check, before business logic (mutations) or in parallel with data fetch (GETs)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-billing-integration/06-02-SUMMARY.md`
</output>
