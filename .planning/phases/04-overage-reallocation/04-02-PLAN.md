---
phase: 04-overage-reallocation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  # dave-ramsey repo
  - src/lib/envelopes/firestore.ts
  # personal-brand repo
  - /Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/types.ts
  - /Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/firestore.ts
  - /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
  - /Users/dweinbeck/Documents/personal-brand/src/components/ui/Modal.tsx
autonomous: true

must_haves:
  truths:
    - "Allocations are created atomically via Firestore batched write linked to source transaction"
    - "Deleting a transaction cascades to delete all linked overage allocations atomically"
    - "Envelope remaining balances account for incoming and outgoing allocations in listEnvelopesWithRemaining"
    - "POST /api/envelopes/allocations validates all constraints server-side before persisting"
    - "Modal component opens/closes in sync with React state, handles Escape key and backdrop clicks"
  artifacts:
    - path: "src/lib/envelopes/firestore.ts"
      provides: "createAllocations, deleteAllocationsForTransaction, extended deleteTransaction and listEnvelopesWithRemaining"
      exports: ["createAllocations", "deleteAllocationsForTransaction"]
    - path: "/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts"
      provides: "POST endpoint for creating overage allocations with full server validation"
      exports: ["POST"]
    - path: "/Users/dweinbeck/Documents/personal-brand/src/components/ui/Modal.tsx"
      provides: "Reusable modal component built on native HTML dialog element"
      exports: ["Modal"]
  key_links:
    - from: "/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts"
      to: "/Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/firestore.ts"
      via: "import createAllocations, validateAllocations"
      pattern: "import.*createAllocations.*from"
    - from: "src/lib/envelopes/firestore.ts"
      to: "src/lib/envelopes/types.ts"
      via: "import OverageAllocationInput"
      pattern: "import.*OverageAllocationInput"
---

<objective>
Add Firestore allocation CRUD helpers (createAllocations, cascading deleteTransaction), extend balance computation in listEnvelopesWithRemaining to account for allocations, create the allocation API endpoint with full server-side validation, and build the reusable Modal component.

Purpose: This plan builds all the server-side infrastructure and the reusable Modal component needed by the overage UI in Plan 04-03. After this plan, allocations can be created and deleted, balances reflect allocation flows, and the Modal shell is ready for the overage form.

Output: Updated firestore.ts (both repos), new allocation API route, new Modal.tsx component.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-overage-reallocation/04-RESEARCH.md
@.planning/phases/04-overage-reallocation/04-01-SUMMARY.md
@src/lib/envelopes/types.ts
@src/lib/envelopes/firestore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add allocation Firestore helpers and extend balance computation</name>
  <files>
    src/lib/envelopes/firestore.ts
    /Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/types.ts
    /Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/firestore.ts
  </files>
  <action>
**In dave-ramsey `src/lib/envelopes/firestore.ts`:**

1. **Add `createAllocations` function** after the existing CRUD operations section:

```typescript
/**
 * Creates overage allocation documents atomically via batched write.
 * Each allocation links a donor envelope to a source transaction.
 */
export async function createAllocations(
  userId: string,
  sourceTransactionId: string,
  allocations: { donorEnvelopeId: string; amountCents: number }[],
): Promise<void> {
  const batch = requireDb().batch();

  for (const alloc of allocations) {
    const docRef = allocationsCol().doc();
    batch.set(docRef, {
      userId,
      sourceTransactionId,
      donorEnvelopeId: alloc.donorEnvelopeId,
      amountCents: alloc.amountCents,
      createdAt: FieldValue.serverTimestamp(),
    });
  }

  await batch.commit();
}
```

2. **Add `deleteAllocationsForTransaction` helper:**

```typescript
/**
 * Deletes all overage allocations linked to a source transaction.
 * Returns the allocation doc refs for use in batch operations.
 */
export async function deleteAllocationsForTransaction(
  transactionId: string,
): Promise<FirebaseFirestore.DocumentReference[]> {
  const allocSnap = await allocationsCol()
    .where("sourceTransactionId", "==", transactionId)
    .get();
  return allocSnap.docs.map((d) => d.ref);
}
```

3. **Update `deleteTransaction` to cascade-delete linked allocations:**

Replace the existing `deleteTransaction` function. After verifying ownership, query `allocationsCol().where("sourceTransactionId", "==", transactionId)`. If allocations exist, use a Firestore batch to delete the transaction + all linked allocations atomically. If no allocations, simple delete (existing behavior).

Remove the `// TODO: Phase 4` comment.

```typescript
export async function deleteTransaction(
  userId: string,
  transactionId: string,
): Promise<void> {
  const docRef = transactionsCol().doc(transactionId);
  const snap = await docRef.get();
  if (!snap.exists || snap.data()?.userId !== userId) {
    throw new Error("Transaction not found or access denied.");
  }

  // Cascade-delete linked overage allocations
  const allocRefs = await deleteAllocationsForTransaction(transactionId);

  if (allocRefs.length === 0) {
    await docRef.delete();
  } else {
    const batch = requireDb().batch();
    batch.delete(docRef);
    for (const ref of allocRefs) {
      batch.delete(ref);
    }
    await batch.commit();
  }
}
```

4. **Extend `listEnvelopesWithRemaining` to account for allocations:**

After fetching envelopes and transactions (the existing parallel fetch), add a third fetch for allocations:
- Get all allocations where `donorEnvelopeId` is in the user's envelope IDs (outgoing/donated allocations)
- Get all allocations where `sourceTransactionId` is in the current-week transaction IDs (incoming/received allocations -- the envelope that received the allocation is the envelope of the source transaction)

Build two maps:
- `receivedByEnvelope: Map<string, number>` -- keyed by the overage envelope ID (the envelope of the source transaction), summing allocation amountCents
- `donatedByEnvelope: Map<string, number>` -- keyed by donorEnvelopeId, summing allocation amountCents

To determine the recipient envelope for each allocation: look up the source transaction's `envelopeId` from the transaction data already fetched. Only include allocations whose source transaction is in the current week.

Pass `receivedByEnvelope.get(doc.id) ?? 0` and `donatedByEnvelope.get(doc.id) ?? 0` to the extended `computeEnvelopeStatus` call.

**Important:** For donor allocations, scope to current week by only counting allocations whose `sourceTransactionId` matches a transaction in the current-week transaction set. This ensures allocations from previous weeks do not affect current-week balances.

Implementation approach for the allocation query:
- After getting `txSnap`, build a `Set<string>` of current-week transaction IDs.
- Fetch donor allocations: `allocationsCol().where("donorEnvelopeId", "in", envelopeIds)` (chunk by 30 for Firestore `in` limit). Filter results where `sourceTransactionId` is in the current-week transaction ID set.
- For each matching allocation: add to `donatedByEnvelope` map (keyed by `donorEnvelopeId`) and to `receivedByEnvelope` map (keyed by the source transaction's `envelopeId`).

If there are no current-week transactions, skip the allocation query entirely (no allocations possible).

5. **Copy updated files to personal-brand repo:**

Copy the updated `src/lib/envelopes/types.ts` to `/Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/types.ts`.

Copy the updated `src/lib/envelopes/firestore.ts` to `/Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/firestore.ts`. Ensure the import paths use `@/lib/firebase` (which is the personal-brand repo convention, same as dave-ramsey).

**Do NOT change the firebase.ts import.** Both repos already use `@/lib/firebase`.
  </action>
  <verify>
Run in dave-ramsey: `npm test` (all existing + TDD tests pass), `npx tsc --noEmit`.
Run in personal-brand: `npx tsc --noEmit` to verify types compile.
Grep for the TODO comment to confirm it's removed: `grep -r "TODO: Phase 4" src/lib/envelopes/`.
  </verify>
  <done>
- `createAllocations` creates allocation documents atomically via batched write
- `deleteAllocationsForTransaction` returns allocation refs for a given transaction
- `deleteTransaction` cascades to linked allocations (batch delete if allocations exist)
- `listEnvelopesWithRemaining` computes `remaining = budget - spent + received - donated` per envelope
- Both repos have updated types.ts and firestore.ts
- TODO comment removed
  </done>
</task>

<task type="auto">
  <name>Task 2: Create allocation API endpoint and reusable Modal component</name>
  <files>
    /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
    /Users/dweinbeck/Documents/personal-brand/src/components/ui/Modal.tsx
  </files>
  <action>
**1. Create `POST /api/envelopes/allocations` endpoint:**

File: `/Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts`

Follow the exact pattern from existing API routes (e.g., `src/app/api/envelopes/transactions/route.ts`):
- Import `unauthorizedResponse, verifyUser` from `@/lib/auth/user`
- Import `createAllocations, validateAllocations, transactionsCol, envelopesForUser, transactionsForUserInWeek, allocationsCol` from `@/lib/envelopes/firestore`
- Import `overageAllocationSchema` from `@/lib/envelopes/types`
- Import `getWeekRange` from `@/lib/envelopes/week-math`
- Import `format` from `date-fns`

POST handler logic:
1. Verify user: `const auth = await verifyUser(request); if (!auth.authorized) return unauthorizedResponse(auth);`
2. Parse body with `overageAllocationSchema.safeParse(body)`. Return 400 on failure.
3. **Verify source transaction exists and belongs to user:** Fetch `transactionsCol().doc(parsed.data.sourceTransactionId)`, check exists and userId matches.
4. **Get the source transaction's envelopeId** from the fetched document.
5. **Get current-week date range** using `getWeekRange(new Date())` and `format(start, "yyyy-MM-dd")`.
6. **Fetch all envelopes and current-week transactions for the user** to compute donor balances. Use `envelopesForUser(auth.uid)` and `transactionsForUserInWeek(auth.uid, weekStartStr, weekEndStr)`.
7. **Also fetch existing allocations** for current-week transactions (same approach as listEnvelopesWithRemaining) to compute accurate remaining balances that account for prior allocations.
8. **Build donorBalances Map** by computing each envelope's effective remaining: `weeklyBudgetCents - spentCents + receivedCents - donatedCents`.
9. **Call `validateAllocations`** with the parsed allocations, the overage amount (Math.abs of the source envelope's remaining), and the donorBalances map.
10. If validation fails, return 400 with `{ error: "Allocation validation failed.", details: result.errors }`.
11. If valid, call `createAllocations(auth.uid, parsed.data.sourceTransactionId, parsed.data.allocations)`.
12. Return 201: `Response.json({ success: true }, { status: 201 })`.

Error handling: Wrap in try/catch. Log `error.message` only (privacy-safe). Return 500 on unexpected errors.

**2. Create reusable Modal component:**

File: `/Users/dweinbeck/Documents/personal-brand/src/components/ui/Modal.tsx`

Build on native HTML `<dialog>` element. Follow the pattern from research exactly:

```typescript
"use client";

import clsx from "clsx";
import { useCallback, useEffect, useRef, type ReactNode } from "react";

type ModalProps = {
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
  className?: string;
} & (
  | { "aria-labelledby": string; "aria-label"?: never }
  | { "aria-label": string; "aria-labelledby"?: never }
);

export function Modal({
  isOpen,
  onClose,
  children,
  className,
  ...ariaProps
}: ModalProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  // Sync open/close state with the native dialog
  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;
    if (isOpen && !dialog.open) {
      dialog.showModal();
    } else if (!isOpen && dialog.open) {
      dialog.close();
    }
  }, [isOpen]);

  // Sync native close events (Escape key) with React state
  const handleClose = useCallback(() => {
    onClose();
  }, [onClose]);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;
    dialog.addEventListener("close", handleClose);
    return () => dialog.removeEventListener("close", handleClose);
  }, [handleClose]);

  // Light dismiss: clicking the backdrop closes the modal
  function handleBackdropClick(e: React.MouseEvent<HTMLDialogElement>) {
    if (e.target === dialogRef.current) {
      onClose();
    }
  }

  return (
    <dialog
      ref={dialogRef}
      onClick={handleBackdropClick}
      className={clsx(
        "max-h-[85vh] w-full max-w-lg rounded-2xl border border-border",
        "bg-surface p-0 shadow-xl",
        "backdrop:bg-black/50",
        className,
      )}
      {...ariaProps}
    >
      {isOpen ? children : null}
    </dialog>
  );
}
```

Key details:
- `isOpen` controls open/close via `showModal()` / `close()`
- `close` event listener syncs Escape key dismissal with React state
- Backdrop click detection via `e.target === dialogRef.current` (clicking the dialog element itself, not its children)
- Discriminated union for ARIA: must provide either `aria-labelledby` or `aria-label` (not neither)
- Only render children when `isOpen` to avoid rendering hidden content
- Use CSS custom properties from globals.css: `border-border`, `bg-surface`
- Verify these class names work with the existing Tailwind 4 config. If `border-border` or `bg-surface` are not defined, use fallbacks: `border-[var(--border)]` and `bg-[var(--surface)]`, or check globals.css for the actual property names and adjust accordingly.
  </action>
  <verify>
In personal-brand repo:
1. `npx tsc --noEmit` -- no type errors
2. `npx biome check src/app/api/envelopes/allocations/route.ts src/components/ui/Modal.tsx` -- lint clean
3. Verify Modal.tsx exports: `grep "export function Modal" src/components/ui/Modal.tsx`
4. Verify route exports POST: `grep "export async function POST" src/app/api/envelopes/allocations/route.ts`
  </verify>
  <done>
- POST /api/envelopes/allocations endpoint validates input with Zod, verifies source transaction ownership, computes live donor balances, validates allocation constraints server-side, and creates allocations atomically
- Modal component built on native `<dialog>` with `showModal()` / `close()`, Escape key sync, backdrop click dismiss, ARIA enforcement
- Both files pass TypeScript and Biome linting
  </done>
</task>

</tasks>

<verification>
```bash
# dave-ramsey repo
cd /Users/dweinbeck/Documents/dave-ramsey && npm test && npx tsc --noEmit

# personal-brand repo
cd /Users/dweinbeck/Documents/personal-brand && npx tsc --noEmit && npx biome check src/app/api/envelopes/allocations/ src/components/ui/Modal.tsx

# Confirm TODO removed
grep -r "TODO: Phase 4" /Users/dweinbeck/Documents/dave-ramsey/src/ /Users/dweinbeck/Documents/personal-brand/src/ || echo "All TODOs resolved"

# Confirm key exports exist
grep "createAllocations\|deleteAllocationsForTransaction\|validateAllocations" /Users/dweinbeck/Documents/personal-brand/src/lib/envelopes/firestore.ts
grep "export function Modal" /Users/dweinbeck/Documents/personal-brand/src/components/ui/Modal.tsx
grep "export async function POST" /Users/dweinbeck/Documents/personal-brand/src/app/api/envelopes/allocations/route.ts
```
</verification>

<success_criteria>
1. `createAllocations` writes all allocation docs atomically in a single batch
2. `deleteTransaction` cascades to linked allocations (batch delete)
3. `listEnvelopesWithRemaining` correctly accounts for `+ received - donated` allocations
4. POST /api/envelopes/allocations validates: source transaction exists + owned, donor allocation <= donor remaining, total == overage
5. Modal opens with `showModal()`, closes on Escape (synced with React state), closes on backdrop click
6. TypeScript compiles in both repos, Biome lint passes in personal-brand
</success_criteria>

<output>
After completion, create `.planning/phases/04-overage-reallocation/04-02-SUMMARY.md`
</output>
